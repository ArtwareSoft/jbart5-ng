var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var core_1 = require('angular2/core');
var async_1 = require('angular2/src/facade/async');
var collection_1 = require('angular2/src/facade/collection');
var exceptions_1 = require('angular2/src/facade/exceptions');
var lang_1 = require('angular2/src/facade/lang');
var dir_1 = require('../core/rtl/dir');
var one_of_1 = require('../core/annotations/one-of');
/**
 * Exception thrown when a MdSidenavLayout is missing both sidenavs.
 */
var MdMissingSidenavException = (function (_super) {
    __extends(MdMissingSidenavException, _super);
    function MdMissingSidenavException() {
        _super.apply(this, arguments);
    }
    return MdMissingSidenavException;
})(exceptions_1.BaseException);
exports.MdMissingSidenavException = MdMissingSidenavException;
/**
 * Exception thrown when two MdSidenav are matching the same side.
 */
var MdDuplicatedSidenavException = (function (_super) {
    __extends(MdDuplicatedSidenavException, _super);
    function MdDuplicatedSidenavException(align) {
        _super.call(this, "A sidenav was already declared for 'align=\"" + align + "\"'");
    }
    return MdDuplicatedSidenavException;
})(exceptions_1.BaseException);
exports.MdDuplicatedSidenavException = MdDuplicatedSidenavException;
/**
 * <md-sidenav> component.
 *
 * This component corresponds to the drawer of the sidenav.
 *
 * Please refer to README.md for examples on how to use it.
 */
var MdSidenav = (function () {
    /**
     * @param _elementRef The DOM element reference. Used for transition and width calculation.
     *     If not available we do not hook on transitions.
     */
    function MdSidenav(_elementRef) {
        this._elementRef = _elementRef;
        /** Alignment of the sidenav (direction neutral); whether 'start' or 'end'. */
        this.align = 'start';
        /** Mode of the sidenav; whether 'over' or 'side'. */
        this.mode = 'over';
        /** Event emitted when the sidenav is being opened. Use this to synchronize animations. */
        this.onOpenStart = new async_1.EventEmitter();
        /** Event emitted when the sidenav is fully opened. */
        this.onOpen = new async_1.EventEmitter();
        /** Event emitted when the sidenav is being closed. Use this to synchronize animations. */
        this.onCloseStart = new async_1.EventEmitter();
        /** Event emitted when the sidenav is fully closed. */
        this.onClose = new async_1.EventEmitter();
        this._transition = false;
    }
    Object.defineProperty(MdSidenav.prototype, "opened", {
        /**
         * Whether the sidenav is opened. We overload this because we trigger an event when it
         * starts or end.
         */
        get: function () { return this._opened; },
        set: function (v) {
            this.toggle(v);
        },
        enumerable: true,
        configurable: true
    });
    /** Open this sidenav, and return a Promise that will resolve when it's fully opened (or get
     * rejected if it didn't). */
    MdSidenav.prototype.open = function () {
        return this.toggle(true);
    };
    /**
     * Close this sidenav, and return a Promise that will resolve when it's fully closed (or get
     * rejected if it didn't).
     */
    MdSidenav.prototype.close = function () {
        return this.toggle(false);
    };
    /**
     * Toggle this sidenav. This is equivalent to calling open() when it's already opened, or
     * close() when it's closed.
     * @param isOpen
     */
    MdSidenav.prototype.toggle = function (isOpen) {
        if (!lang_1.isPresent(isOpen)) {
            isOpen = !this.opened;
        }
        // Shortcut it if we're already opened.
        if (isOpen === this.opened) {
            if (!this._transition) {
                return async_1.PromiseWrapper.resolve(null);
            }
            else {
                return isOpen ? this._openPromise : this._closePromise;
            }
        }
        this._opened = isOpen;
        this._transition = true;
        if (isOpen) {
            this.onOpenStart.emit(null);
        }
        else {
            this.onCloseStart.emit(null);
        }
        if (isOpen) {
            if (this._openPromise == null) {
                var completer = async_1.PromiseWrapper.completer();
                this._openPromise = completer.promise;
                this._openPromiseReject = completer.reject;
                this._openPromiseResolve = completer.resolve;
            }
            return this._openPromise;
        }
        else {
            if (this._closePromise == null) {
                var completer = async_1.PromiseWrapper.completer();
                this._closePromise = completer.promise;
                this._closePromiseReject = completer.reject;
                this._closePromiseResolve = completer.resolve;
            }
            return this._closePromise;
        }
    };
    /**
     * When transition has finished, set the internal state for classes and emit the proper event.
     * The event passed is actually of type TransitionEvent, but that type is not available in
     * Android so we use any.
     * @param e The event.
     * @private
     */
    MdSidenav.prototype.onTransitionEnd = function (e) {
        if (e.target == this._elementRef.nativeElement
            && e.propertyName.endsWith('transform')) {
            this._transition = false;
            if (this._opened) {
                if (this._openPromise != null) {
                    this._openPromiseResolve();
                }
                if (this._closePromise != null) {
                    this._closePromiseReject();
                }
                this.onOpen.emit(null);
            }
            else {
                if (this._closePromise != null) {
                    this._closePromiseResolve();
                }
                if (this._openPromise != null) {
                    this._openPromiseReject();
                }
                this.onClose.emit(null);
            }
            this._openPromise = null;
            this._closePromise = null;
        }
    };
    Object.defineProperty(MdSidenav.prototype, "_isClosing", {
        get: function () {
            return !this._opened && this._transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_isOpening", {
        get: function () {
            return this._opened && this._transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_isClosed", {
        get: function () {
            return !this._opened && !this._transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_isOpened", {
        get: function () {
            return this._opened && !this._transition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_isEnd", {
        get: function () {
            return this.align == 'end';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_modeSide", {
        get: function () {
            return this.mode == 'side';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_modeOver", {
        get: function () {
            return this.mode == 'over';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_modePush", {
        get: function () {
            return this.mode == 'push';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "_width", {
        /**
         * This is public because we need it from MdSidenavLayout, but it's undocumented and should
         * not be used outside.
         * @private
         */
        get: function () {
            if (this._elementRef.nativeElement) {
                return this._elementRef.nativeElement.offsetWidth;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        core_1.Input(),
        one_of_1.OneOf(['start', 'end']), 
        __metadata('design:type', String)
    ], MdSidenav.prototype, "align", void 0);
    __decorate([
        core_1.Input(),
        one_of_1.OneOf(['over', 'push', 'side']), 
        __metadata('design:type', String)
    ], MdSidenav.prototype, "mode", void 0);
    __decorate([
        core_1.Input('opened'), 
        __metadata('design:type', Boolean)
    ], MdSidenav.prototype, "_opened", void 0);
    __decorate([
        core_1.Output('open-start'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "onOpenStart", void 0);
    __decorate([
        core_1.Output('open'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "onOpen", void 0);
    __decorate([
        core_1.Output('close-start'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "onCloseStart", void 0);
    __decorate([
        core_1.Output('close'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "onClose", void 0);
    __decorate([
        core_1.HostListener('transitionend', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], MdSidenav.prototype, "onTransitionEnd", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-closing'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_isClosing", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-opening'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_isOpening", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-closed'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_isClosed", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-opened'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_isOpened", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-end'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_isEnd", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-side'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_modeSide", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-over'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_modeOver", null);
    __decorate([
        core_1.HostBinding('class.md-sidenav-push'), 
        __metadata('design:type', Object)
    ], MdSidenav.prototype, "_modePush", null);
    MdSidenav = __decorate([
        core_1.Component({
            selector: 'md-sidenav',
            template: '<ng-content></ng-content>',
            changeDetection: core_1.ChangeDetectionStrategy.OnPush,
        }), 
        __metadata('design:paramtypes', [core_1.ElementRef])
    ], MdSidenav);
    return MdSidenav;
})();
exports.MdSidenav = MdSidenav;
/**
 * <md-sidenav-layout> component.
 *
 * This is the parent component to one or two <md-sidenav>s that validates the state internally
 * and coordinate the backdrop and content styling.
 */
var MdSidenavLayout = (function () {
    function MdSidenavLayout(_dir) {
        var _this = this;
        this._dir = _dir;
        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right
        // properties to point to the proper start/end.
        if (_dir != null) {
            _dir.dirChange.add(function () { return _this._validateDrawers(); });
        }
    }
    Object.defineProperty(MdSidenavLayout.prototype, "start", {
        get: function () { return this._start; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenavLayout.prototype, "end", {
        get: function () { return this._end; },
        enumerable: true,
        configurable: true
    });
    MdSidenavLayout.prototype.ngAfterContentInit = function () {
        var _this = this;
        // On changes, assert on consistency.
        async_1.ObservableWrapper.subscribe(this._sidenavs.changes, function () { return _this._validateDrawers(); });
        this._validateDrawers();
    };
    /**
     * Validate the state of the sidenav children components.
     * @private
     */
    MdSidenavLayout.prototype._validateDrawers = function () {
        var _this = this;
        this._start = this._end = null;
        if (this._sidenavs.length === 0) {
            throw new MdMissingSidenavException();
        }
        // Ensure that we have at most one start and one end sidenav.
        collection_1.iterateListLike(this._sidenavs, function (sidenav) {
            if (sidenav.align == 'end') {
                if (_this._end != null) {
                    throw new MdDuplicatedSidenavException('end');
                }
                _this._end = sidenav;
            }
            else {
                if (_this._start != null) {
                    throw new MdDuplicatedSidenavException('start');
                }
                _this._start = sidenav;
            }
        });
        this._right = this._left = null;
        // Detect if we're LTR or RTL.
        if (this._dir == null || this._dir.value == 'ltr') {
            this._left = this._start;
            this._right = this._end;
        }
        else {
            this._left = this._end;
            this._right = this._start;
        }
    };
    MdSidenavLayout.prototype._closeModalSidenav = function () {
        if (this._start != null && this._start.mode != 'side') {
            this._start.close();
        }
        if (this._end != null && this._end.mode != 'side') {
            this._end.close();
        }
    };
    MdSidenavLayout.prototype._isShowingBackdrop = function () {
        return (this._start != null && this._start.mode != 'side' && this._start.opened)
            || (this._end != null && this._end.mode != 'side' && this._end.opened);
    };
    /**
     * Return the width of the sidenav, if it's in the proper mode and opened.
     * This may relayout the view, so do not call this often.
     * @param MdSidenav
     * @private
     */
    MdSidenavLayout.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {
        if (sidenav != null && sidenav.mode == mode && sidenav.opened) {
            return sidenav._width;
        }
        return 0;
    };
    MdSidenavLayout.prototype._getMarginLeft = function () {
        return this._getSidenavEffectiveWidth(this._left, 'side');
    };
    MdSidenavLayout.prototype._getMarginRight = function () {
        return this._getSidenavEffectiveWidth(this._right, 'side');
    };
    MdSidenavLayout.prototype._getPositionLeft = function () {
        return this._getSidenavEffectiveWidth(this._left, 'push');
    };
    MdSidenavLayout.prototype._getPositionRight = function () {
        return this._getSidenavEffectiveWidth(this._right, 'push');
    };
    __decorate([
        core_1.ContentChildren(MdSidenav), 
        __metadata('design:type', core_1.QueryList)
    ], MdSidenavLayout.prototype, "_sidenavs", void 0);
    MdSidenavLayout = __decorate([
        core_1.Component({
            selector: 'md-sidenav-layout',
        }),
        core_1.View({
            directives: [MdSidenav],
            template: `
              <div class="md-sidenav-backdrop" (click)="_closeModalSidenav()"
                   [class.md-sidenav-shown]="_isShowingBackdrop()"></div>

              <ng-content select="md-sidenav"></ng-content>

              <md-content [style.margin-left.px]="_getMarginLeft()"
                          [style.margin-right.px]="_getMarginRight()"
                          [style.left.px]="_getPositionLeft()"
                          [style.right.px]="_getPositionRight()">
                <ng-content></ng-content>
              </md-content>
            `,
            styles: [`
              /**
               * Mixin that creates a new stacking context.
               * see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
               */
              /**
               * Mixin to help with defining LTR/RTL 'transform: translateX()' values.
               * @param $open The translation value when the sidenav is opened.
               * @param $close The translation value when the sidenav is closed.
               */
              :host {
                position: relative;
                -webkit-transform: translate3D(0, 0, 0);
                        transform: translate3D(0, 0, 0);
                box-sizing: border-box;
                display: block;
                overflow-x: hidden; }
                :host > .md-sidenav-backdrop {
                  position: absolute;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  display: block;
                  z-index: 2;
                  visibility: hidden; }
                  :host > .md-sidenav-backdrop.md-sidenav-shown {
                    visibility: visible;
                    background-color: rgba(0, 0, 0, 0.6); }
                :host > md-content {
                  position: relative;
                  -webkit-transform: translate3D(0, 0, 0);
                          transform: translate3D(0, 0, 0);
                  display: block; }
                :host > md-sidenav {
                  position: relative;
                  -webkit-transform: translate3D(0, 0, 0);
                          transform: translate3D(0, 0, 0);
                  display: block;
                  position: fixed;
                  top: 0;
                  bottom: 0;
                  z-index: 3;
                  background-color: white;
                  -webkit-transform: translateX(-100%);
                          transform: translateX(-100%); }
                  :host > md-sidenav.md-sidenav-closed {
                    visibility: hidden; }
                  :host > md-sidenav.md-sidenav-closing {
                    -webkit-transform: translateX(-100%);
                            transform: translateX(-100%);
                    will-change: transform; }
                  :host > md-sidenav.md-sidenav-opening {
                    visibility: visible;
                    -webkit-transform: translateX(0);
                            transform: translateX(0);
                    will-change: transform;
                    box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
                  :host > md-sidenav.md-sidenav-opened {
                    -webkit-transform: translateX(0);
                            transform: translateX(0);
                    box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
                  :host > md-sidenav.md-sidenav-push {
                    background-color: white; }
                  :host > md-sidenav.md-sidenav-side {
                    z-index: 1; }
                  :host > md-sidenav.md-sidenav-end {
                    right: 0;
                    -webkit-transform: translateX(100%);
                            transform: translateX(100%); }
                    :host > md-sidenav.md-sidenav-end.md-sidenav-closed {
                      visibility: hidden; }
                    :host > md-sidenav.md-sidenav-end.md-sidenav-closing {
                      -webkit-transform: translateX(100%);
                              transform: translateX(100%);
                      will-change: transform; }
                    :host > md-sidenav.md-sidenav-end.md-sidenav-opening {
                      visibility: visible;
                      -webkit-transform: translateX(0);
                              transform: translateX(0);
                      will-change: transform;
                      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
                    :host > md-sidenav.md-sidenav-end.md-sidenav-opened {
                      -webkit-transform: translateX(0);
                              transform: translateX(0);
                      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }

              :host-context([dir="rtl"]) > md-sidenav {
                -webkit-transform: translateX(100%);
                        transform: translateX(100%); }
                :host-context([dir="rtl"]) > md-sidenav.md-sidenav-closed {
                  visibility: hidden; }
                :host-context([dir="rtl"]) > md-sidenav.md-sidenav-closing {
                  -webkit-transform: translateX(100%);
                          transform: translateX(100%);
                  will-change: transform; }
                :host-context([dir="rtl"]) > md-sidenav.md-sidenav-opening {
                  visibility: visible;
                  -webkit-transform: translateX(0);
                          transform: translateX(0);
                  will-change: transform;
                  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
                :host-context([dir="rtl"]) > md-sidenav.md-sidenav-opened {
                  -webkit-transform: translateX(0);
                          transform: translateX(0);
                  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
                :host-context([dir="rtl"]) > md-sidenav.md-sidenav-end {
                  left: 0;
                  right: auto;
                  -webkit-transform: translateX(-100%);
                          transform: translateX(-100%); }
                  :host-context([dir="rtl"]) > md-sidenav.md-sidenav-end.md-sidenav-closed {
                    visibility: hidden; }
                  :host-context([dir="rtl"]) > md-sidenav.md-sidenav-end.md-sidenav-closing {
                    -webkit-transform: translateX(-100%);
                            transform: translateX(-100%);
                    will-change: transform; }
                  :host-context([dir="rtl"]) > md-sidenav.md-sidenav-end.md-sidenav-opening {
                    visibility: visible;
                    -webkit-transform: translateX(0);
                            transform: translateX(0);
                    will-change: transform;
                    box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
                  :host-context([dir="rtl"]) > md-sidenav.md-sidenav-end.md-sidenav-opened {
                    -webkit-transform: translateX(0);
                            transform: translateX(0);
                    box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26); }
              /**
               * We separate transitions to be able to disable them in unit tests, by simply not loading this file.
               */
              :host {
                transition: margin-left 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), margin-right 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
                :host > .md-sidenav-backdrop.md-sidenav-shown {
                  transition: background-color 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
                :host > md-content {
                  transition: margin-left 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), margin-right 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), left 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), right 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
                :host > md-sidenav {
                  transition: -webkit-transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
                  transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
                  transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), -webkit-transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
            `],
        }),
        __param(0, core_1.Optional()),
        __param(0, core_1.Host()), 
        __metadata('design:paramtypes', [dir_1.Dir])
    ], MdSidenavLayout);
    return MdSidenavLayout;
})();
exports.MdSidenavLayout = MdSidenavLayout;
exports.MD_SIDENAV_DIRECTIVES = lang_1.CONST_EXPR([MdSidenavLayout, MdSidenav]);
//# sourceMappingURL=../../../../components/sidenav/sidenav.js.map